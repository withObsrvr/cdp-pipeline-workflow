# Alternative: Use WalletBackendProcessor which passes through full ledger
# while extracting state changes as metadata
pipelines:
  FullLedgerWithStateChanges:
    source:
      type: BufferedStorageSourceAdapter
      config:
        bucket_name: "obsrvr-stellar-ledger-data-mainnet-data/landing/ledgers/mainnet"
        network: "mainnet"
        num_workers: 20
        retry_limit: 3
        retry_wait: 5
        start_ledger: 52000000
        end_ledger: "latest"
        continuous_mode: true
        ledgers_per_file: 1
        files_per_partition: 64000
    
    processors:
      # WalletBackendProcessor maintains full ledger payload
      # while adding state_changes to metadata
      - type: "WalletBackend"
        name: "ledger-with-state-changes"
        config:
          network_passphrase: "Public Global Stellar Network ; September 2015"
          extract_contract_events: false  # Disable if not needed for performance
          track_participants: false       # Disable if not needed
    
    consumers:
      - type: SaveToParquet
        config:
          storage_type: "GCS"
          bucket_name: "your-data-lake-bucket"
          path_prefix: "silver/full_ledger_with_state"
          
          # Optimized for large XDR payloads
          partition_by: "ledger_sequence_day"
          max_file_size_mb: 1024              # 1GB files
          compression: "zstd"
          buffer_size: 500
          write_batch_size: 250
          
          # Handle nested XDR structure
          flatten_nested_fields: false        # Keep XDR structure intact
          binary_encoding: "base64"           # Encode binary XDR fields
          
          # Performance tuning
          parallel_writes: 4                  # Parallel file writers
          memory_buffer_mb: 512               # Memory buffer per writer